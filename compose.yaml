services:
  grist:
    image: gristlabs/grist:latest
    environment:
      # Enable sandboxing
      GRIST_SANDBOX_FLAVOR: gvisor

      # Forces Grist to only use a single team called 'GristCon'
      GRIST_SINGLE_ORG: brightstar   # alternatively, GRIST_ORG_IN_PATH: "true" for multi-team operation
      # Force users to login (disable anonymous access)
      GRIST_FORCE_LOGIN: true
      # Default email for the "Admin" account
      GRIST_DEFAULT_EMAIL: ${GRIST_DEFAULT_EMAIL}

      # Postgres database setup
      TYPEORM_DATABASE: grist
      TYPEORM_USERNAME: grist
      TYPEORM_HOST: grist-db
      TYPEORM_LOGGING: false
      TYPEORM_PASSWORD: ${DATABASE_PASSWORD}
      TYPEORM_PORT: 5432
      TYPEORM_TYPE: postgres

      # Redis setup
      REDIS_URL: redis://grist-redis

      # MinIO setup. This requires the bucket set up on the MinIO instance with versioning enabled.
      GRIST_DOCS_MINIO_ACCESS_KEY: grist
      GRIST_DOCS_MINIO_SECRET_KEY: ${MINIO_PASSWORD}
      GRIST_DOCS_MINIO_USE_SSL: 0
      GRIST_DOCS_MINIO_BUCKET: grist-docs
      GRIST_DOCS_MINIO_ENDPOINT: grist-minio
      GRIST_DOCS_MINIO_PORT: 9000

      # External Storage for attachments
      GRIST_EXTERNAL_ATTACHMENTS_MODE: "snapshots"

      GRIST_OIDC_SP_HOST: https://${GRIST_DOMAIN}
      GRIST_OIDC_IDP_ISSUER: https://${GRIST_DOMAIN}/keycloak/realms/myrealm
      GRIST_OIDC_IDP_SCOPES: openid profile email

      # the ID you chose for the Keycloak client
      GRIST_OIDC_IDP_CLIENT_ID: gristclient

      # the client secret generated by Keycloak retrieved earlier
      GRIST_OIDC_IDP_CLIENT_SECRET: ${OIDC_CLIENT_SECRET}

      GRIST_OIDC_SP_EXTRA_PROPS_TO_STORE: email_verified,preferred_username
    volumes:
      # Where to store persistent data, such as documents.
      - ${PERSIST_DIR}/grist:/persist
    ports:
      - "8484:8484"
    depends_on:
      grist-db:
        condition: service_started
      grist-redis:
        condition: service_started
      grist-minio:
        condition: service_started
      minio-setup:
        condition: service_completed_successfully
      kc_postgresql:
        condition: service_started
      keycloak:
        condition: service_healthy

    develop:
      watch:
      - action: sync+restart
        path: ../../_build
        target: /grist/_build


  grist-db:
    image: postgres:alpine
    environment:
        POSTGRES_DB: grist
        POSTGRES_USER: grist
        POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
    ports:
      - "5434:5432"
    volumes:
      - ${PERSIST_DIR}/postgres:/var/lib/postgresql/data

  grist-redis:
    image: redis:alpine
    volumes:
      - ${PERSIST_DIR}/redis:/data

  grist-minio:
    image: minio/minio:latest
    environment:
      MINIO_ROOT_USER: grist
      MINIO_ROOT_PASSWORD: ${MINIO_PASSWORD}
    volumes:
      - ${PERSIST_DIR}/minio:/data
    command:
      server /data --console-address=":9001"

  # This sets up the buckets required in MinIO. It is only needed to make this example work.
  # It isn't necessary for deployment and can be safely removed.
  minio-setup:
    image: minio/mc
    environment:
      MINIO_PASSWORD: ${MINIO_PASSWORD}
    depends_on:
      grist-minio:
        condition: service_started
    restart: on-failure
    entrypoint: >
      /bin/sh -c "
      /usr/bin/mc alias set myminio http://grist-minio:9000 grist '$MINIO_PASSWORD';
      /usr/bin/mc mb myminio/grist-docs;
      /usr/bin/mc anonymous set public myminio/grist-docs;
      /usr/bin/mc version enable myminio/grist-docs;
      "
    labels:
      - "traefik.enable=false"

  kc_postgresql:
    image: postgres:alpine
    ports:
      - "5433:5432"
    environment:
      # Postgresql db container configuration
      POSTGRES_DB: keycloak
      POSTGRES_USER: grist
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}

      # App database configuration (not used by postgres, but kept for reference)
      DB_HOST: kc_postgresql
      DB_NAME: keycloak
      DB_USER: grist
      DB_PASSWORD: ${DATABASE_PASSWORD}
      DB_PORT: "5433"
    volumes:
      - ${PERSIST_DIR}/keycloak/db:/var/lib/postgresql/data

  keycloak:
    image: quay.io/keycloak/keycloak:26.2.0
    volumes:
      - ${PERSIST_DIR}/keycloak/auth:/opt/keycloak/data/import
    command:
      - start
      - --import-realm
    environment:
      KC_BOOTSTRAP_ADMIN_USERNAME: admin
      KC_BOOTSTRAP_ADMIN_PASSWORD: admin
      KC_DB: postgres
      KC_DB_URL_HOST: kc_postgresql
      KC_DB_URL_DATABASE: keycloak
      KC_DB_PASSWORD: ${DATABASE_PASSWORD}
      KC_DB_USERNAME: grist
      KC_DB_SCHEMA: public

      KC_HTTP_ENABLED: true
      KC_HTTP_RELATIVE_PATH: /keycloak
      KC_PROXY: edge
      KC_PROXY_HEADERS: xforwarded
      KC_HOSTNAME_STRICT: false
      KC_HOSTNAME_STRICT_BACKCHANNEL: false
      KC_HOSTNAME_URL: https://${GRIST_DOMAIN}/keycloak
      KC_HOSTNAME_ADMIN_URL: https://${GRIST_DOMAIN}/keycloak
      KC_HOSTNAME_PORT: -1
    ports:
      - "8080:8080"
      - "8083:8083"
      - "9080:9000"
    depends_on:
      - kc_postgresql
    healthcheck:
      # This healthcheck is a way to wait for Keycloak to be ready. It only checks Keycloak's health once since healthchecks in KC are sometimes weird : https://github.com/keycloak/keycloak/discussions/10575
      test: ["CMD-SHELL", "if [ ! -f /tmp/health.txt ]; then touch /tmp/health.txt && exec 3<>/dev/tcp/127.0.0.1/9000;echo -e 'GET /health/ready HTTP/1.1\r\nhost: http://localhost\r\nConnection: close\r\n\r\n' >&3;if [ $? -eq 0 ]; then echo 'Healthcheck Successful';exit 0;else echo 'Healthcheck Failed';exit 1;fi; else echo \"Healthcheck already executed\"; fi"]

  homarr:
    container_name: homarr
    image: ghcr.io/homarr-labs/homarr:latest
    restart: unless-stopped
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock  # For Docker integration
      - ${PERSIST_DIR}/homarr/appdata:/appdata
    environment:
      - SECRET_ENCRYPTION_KEY=${HOMARR_SECRET_KEY}
    ports:
      - '7575:7575'

  dashdot:
    container_name: dashdot
    image: mauricenino/dashdot:latest
    restart: unless-stopped
    privileged: true  # Required for system monitoring
    ports:
      - '3001:3001'  # Host port 3001 maps to container port 3001
    volumes:
      - /:/mnt/host:ro  # Read-only mount of root filesystem for system stats

  ollama:
    container_name: ollama
    image: ollama/ollama:latest
    restart: unless-stopped
    ports:
      - "11434:11434"  # Ollama API port
    volumes:
      - ${PERSIST_DIR}/ollama:/root/.ollama  # Persistent storage for models
    environment:
      - OLLAMA_HOST=0.0.0.0:11434
    # Optional: Uncomment if you have a GPU and want to use it
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: all
    #           capabilities: [gpu]

  anythingllm:
    container_name: anythingllm
    image: mintplexlabs/anythingllm
    restart: unless-stopped
    ports:
      - "3002:3001"  # Host port 3002 maps to container port 3001 (3001 already used by dashdot)
    cap_add:
      - SYS_ADMIN
    environment:
      - STORAGE_DIR=/app/server/storage
      - JWT_SECRET=${ANYTHINGLLM_JWT_SECRET:-"make this a large list of random numbers and letters 20+"}
      - LLM_PROVIDER=ollama
      - OLLAMA_BASE_PATH=http://ollama:11434
      - OLLAMA_MODEL_PREF=llama2
      - OLLAMA_MODEL_TOKEN_LIMIT=4096
      - EMBEDDING_ENGINE=ollama
      - EMBEDDING_BASE_PATH=http://ollama:11434
      - EMBEDDING_MODEL_PREF=nomic-embed-text:latest
      - EMBEDDING_MODEL_MAX_CHUNK_LENGTH=8192
      - VECTOR_DB=lancedb
      - WHISPER_PROVIDER=local
      - TTS_PROVIDER=native
      - PASSWORDMINCHAR=8
    volumes:
      - ${PERSIST_DIR}/anythingllm:/app/server/storage
      - ${PERSIST_DIR}/anythingllm/.env:/app/server/.env
    depends_on:
      - ollama

  stirling-pdf:
    container_name: stirling-pdf
    image: frooodle/s-pdf:latest
    restart: unless-stopped
    ports:
      - "8081:8080"  # Host port 8081 maps to container port 8080 (8080 already used by keycloak)
    volumes:
      - ${PERSIST_DIR}/stirling-pdf/trainingData:/usr/share/tessdata  # Required for extra OCR languages
      - ${PERSIST_DIR}/stirling-pdf/extraConfigs:/configs
      - ${PERSIST_DIR}/stirling-pdf/customFiles:/customFiles
      - ${PERSIST_DIR}/stirling-pdf/logs:/logs
      - ${PERSIST_DIR}/stirling-pdf/pipeline:/pipeline
    environment:
      - DISABLE_ADDITIONAL_FEATURES=false
      - LANGS=en_GB

  docuseal-db:
    container_name: docuseal-db
    image: postgres:alpine
    restart: unless-stopped
    ports:
      - "5435:5432"  # Host port 5435 maps to container port 5432
    environment:
      POSTGRES_DB: docuseal
      POSTGRES_USER: docuseal
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
    volumes:
      - ${PERSIST_DIR}/docuseal/db:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U docuseal"]
      interval: 5s
      timeout: 5s
      retries: 5

  docuseal:
    container_name: docuseal
    image: docuseal/docuseal:latest
    restart: unless-stopped
    ports:
      - "3000:3000"  # DocuSeal web interface
    volumes:
      - ${PERSIST_DIR}/docuseal/data:/data
    environment:
      - DATABASE_URL=postgresql://docuseal:${DATABASE_PASSWORD}@docuseal-db:5432/docuseal
      - FORCE_SSL=false
    depends_on:
      docuseal-db:
        condition: service_healthy

  collabora-online:
    container_name: collabora-online
    image: collabora/code:latest
    restart: unless-stopped
    ports:
      - "9980:9980"  # Expose Collabora on host port 9980
    extra_hosts:
      - "localhost:172.18.0.1"  # Map localhost to Docker gateway IP so Collabora can reach Nextcloud on host
    cap_add:
      - SYS_CHROOT  # Required for chroot operations during jail setup
      - SYS_ADMIN    # Needed for unshare syscalls and namespace creation
      - FOWNER       # Required for Debian-based distributions
      - CHOWN        # Required for Debian-based distributions
    cap_drop:
      - ALL  # Drop all capabilities except the ones we explicitly add
    environment:
      # WOPI host configuration - configure allowed domains that can connect
      # Example: aliasgroup1=https://yourdomain.com:443
      # Use ${COLLABORA_ALIASGROUP1} or set directly
      # For local HTTP use: allow IP address (accessible from both browser and Docker network)
      - aliasgroup1=${COLLABORA_ALIASGROUP1:-http://192\.168\.1\.205:8082}  # Matches Nextcloud IP address
      # Admin console credentials (optional)
      - username=${COLLABORA_ADMIN_USER:-admin}
      - password=${COLLABORA_ADMIN_PASSWORD:-}
      # Server name for proxy configuration (set if behind reverse proxy)
      # This should be the URL that browsers can access Collabora from
      - server_name=${COLLABORA_SERVER_NAME:-192.168.1.205:9980}
      # SSL certificate domain (optional)
      - cert_domain=${COLLABORA_CERT_DOMAIN:-}
      # Dictionaries - space separated list of language codes (default: de_DE en_GB en_US es_ES fr_FR it nl pt_BR pt_PT ru)
      - dictionaries=${COLLABORA_DICTIONARIES:-}
      # Extra parameters for coolwsd (optional)
      # Disable SSL for local HTTP use
      - extra_params=${COLLABORA_EXTRA_PARAMS:---o:ssl.enable=false}
    # Optional: Uncomment to use custom seccomp profile for enhanced security
    # security_opt:
    #   - seccomp=/path/to/cool-seccomp-profile.json

  nextcloud-db:
    container_name: nextcloud-db
    image: postgres:alpine
    restart: unless-stopped
    ports:
      - "5436:5432"  # Host port 5436 maps to container port 5432
    environment:
      POSTGRES_DB: nextcloud
      POSTGRES_USER: nextcloud
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
    volumes:
      - ${PERSIST_DIR}/nextcloud/db:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U nextcloud"]
      interval: 5s
      timeout: 5s
      retries: 5

  nextcloud-redis:
    container_name: nextcloud-redis
    image: redis:alpine
    restart: unless-stopped
    volumes:
      - ${PERSIST_DIR}/nextcloud/redis:/data
    command: redis-server --requirepass ${DATABASE_PASSWORD}

  nextcloud:
    container_name: nextcloud
    image: nextcloud:latest
    restart: unless-stopped
    ports:
      - "8082:80"  # Host port 8082 maps to container port 80
    volumes:
      - ${PERSIST_DIR}/nextcloud/html:/var/www/html
      - ${PERSIST_DIR}/nextcloud/config:/var/www/html/config
      - ${PERSIST_DIR}/nextcloud/data:/var/www/html/data
      # Share paperless-ngx consume folder for integration - files dropped here will be processed
      - ${PERSIST_DIR}/paperless/consume:/paperless-consume
    environment:
      - POSTGRES_HOST=nextcloud-db
      - POSTGRES_DB=nextcloud
      - POSTGRES_USER=nextcloud
      - POSTGRES_PASSWORD=${DATABASE_PASSWORD}
      - REDIS_HOST=nextcloud-redis
      - REDIS_HOST_PASSWORD=${DATABASE_PASSWORD}
      # Collabora Online integration - configure this in Nextcloud admin panel
      # Set WOPI URL to: http://collabora-online:9980
    depends_on:
      nextcloud-db:
        condition: service_healthy
      nextcloud-redis:
        condition: service_started
      collabora-online:
        condition: service_started

  paperless-db:
    container_name: paperless-db
    image: postgres:alpine
    restart: unless-stopped
    ports:
      - "5437:5432"  # Host port 5437 maps to container port 5432
    environment:
      POSTGRES_DB: paperless
      POSTGRES_USER: paperless
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD}
    volumes:
      - ${PERSIST_DIR}/paperless/db:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U paperless"]
      interval: 5s
      timeout: 5s
      retries: 5

  paperless-redis:
    container_name: paperless-redis
    image: redis:alpine
    restart: unless-stopped
    volumes:
      - ${PERSIST_DIR}/paperless/redis:/data
    command: redis-server --requirepass ${DATABASE_PASSWORD}

  paperless-ngx:
    container_name: paperless-ngx
    image: ghcr.io/paperless-ngx/paperless-ngx:latest
    restart: unless-stopped
    ports:
      - "8000:8000"  # Paperless-ngx web interface
    volumes:
      - ${PERSIST_DIR}/paperless/data:/usr/src/paperless/data
      - ${PERSIST_DIR}/paperless/media:/usr/src/paperless/media
      - ${PERSIST_DIR}/paperless/export:/usr/src/paperless/export
      - ${PERSIST_DIR}/paperless/consume:/usr/src/paperless/consume
    environment:
      - PAPERLESS_REDIS=redis://:${DATABASE_PASSWORD}@paperless-redis:6379
      - PAPERLESS_DBHOST=paperless-db
      - PAPERLESS_DBNAME=paperless
      - PAPERLESS_DBUSER=paperless
      - PAPERLESS_DBPASS=${DATABASE_PASSWORD}
      - PAPERLESS_SECRET_KEY=${PAPERLESS_SECRET_KEY}
      - PAPERLESS_TIME_ZONE=${PAPERLESS_TIME_ZONE:-America/Chicago}
      - PAPERLESS_OCR_LANGUAGE=${PAPERLESS_OCR_LANGUAGE:-eng}
      - PAPERLESS_URL=http://192.168.1.205:8000
      # Nextcloud integration - API token for Nextcloud Paperless app
      - PAPERLESS_API_TOKEN=${PAPERLESS_API_TOKEN:-}
    depends_on:
      paperless-db:
        condition: service_healthy
      paperless-redis:
        condition: service_started

